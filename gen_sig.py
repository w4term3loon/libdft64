#!/usr/bin/env python3
"""
Simple signature extractor for taint analysis.
Extracts function signatures from headers and labels them as IO_SRC, IO_SINK, or NO_IO.
"""

import argparse
import clang.cindex as cc

def is_pointer(type_obj):
    """Check if a type is a pointer."""
    return type_obj.kind == cc.TypeKind.POINTER

def is_const_pointer(type_obj):
    """Check if a type is a const pointer."""
    if not is_pointer(type_obj):
        return False
    pointee = type_obj.get_pointee()
    return pointee.is_const_qualified()

def classify_function(cursor):
    """Classify function based on its signature."""
    args = list(cursor.get_arguments())
    return_type = cursor.result_type

    has_const_ptr_input = False
    has_non_const_ptr_input = False
    has_non_const_ptr_output = False
    returns_pointer = is_pointer(return_type)

    # Analyze arguments
    for arg in args:
        if is_pointer(arg.type):
            if is_const_pointer(arg.type):
                has_const_ptr_input = True
            else:
                has_non_const_ptr_input = True
                # Non-const pointers can be output parameters
                has_non_const_ptr_output = True

    # Classification logic:
    # IO_SRC: Functions that can produce data (non-const ptr args or ptr return)
    # IO_SINK: Functions that can consume data (const ptr inputs)
    # NO_IO: Functions with no pointer arguments or returns

    flags = []

    # Check for source behavior (produces data)
    if has_non_const_ptr_output or returns_pointer:
        flags.append("IO_SRC")

    # Check for sink behavior (consumes data)
    if has_const_ptr_input or has_non_const_ptr_input:
        flags.append("IO_SINK")

    # If no pointer interactions, mark as NO_IO
    if not flags:
        flags.append("NO_IO")

    return "|".join(flags)

def extract_function_signature(cursor):
    """Extract signature info from a function declaration."""
    name = cursor.spelling
    args = list(cursor.get_arguments())
    flags = classify_function(cursor)

    return {
        'name': name,
        'flags': flags,
        'nargs': len(args)
    }

def main():
    parser = argparse.ArgumentParser(description='Extract function signatures for taint analysis')
    parser.add_argument('headers', nargs='+', help='Header files to process')
    parser.add_argument('-o', '--output', required=True, help='Output file')
    parser.add_argument('-I', '--include', action='append', default=[], help='Include directories')

    args = parser.parse_args()

    # Set up clang
    try:
        cc.Config.set_library_file("libclang.so")
    except:
        pass  # Try default location

    clang_args = [f"-I{path}" for path in args.include]

    signatures = []

    # Process each header file
    for header in args.headers:
        print(f"Processing {header}...")

        try:
            index = cc.Index.create()
            tu = index.parse(header, args=clang_args)

            # Find all function declarations
            for cursor in tu.cursor.walk_preorder():
                if (cursor.kind == cc.CursorKind.FUNCTION_DECL and 
                    not cursor.is_definition()):

                    sig = extract_function_signature(cursor)
                    signatures.append(sig)

        except Exception as e:
            print(f"Error processing {header}: {e}")

    # Remove duplicates and sort
    unique_sigs = {sig['name']: sig for sig in signatures}
    sorted_sigs = sorted(unique_sigs.values(), key=lambda x: x['name'])

    # Write output in compatible format
    with open(args.output, 'w') as f:
        f.write("// DO NOT EDIT THIS FILE!\n// Auto-generated function signatures for taint analysis\n")

        for sig in sorted_sigs:
            # Create dummy len_map for compatibility (6 elements, all -1)
            len_map = ", ".join(["-1"] * 6)
            f.write(f'TF_SIG_ENTRY("{sig["name"]}", {sig["flags"]}, {sig["nargs"]}, {len_map})\n')

    # Print summary
    flag_counts = {}
    for sig in sorted_sigs:
        flags = sig['flags']
        flag_counts[flags] = flag_counts.get(flags, 0) + 1

    print(f"\nProcessed {len(sorted_sigs)} unique functions:")
    for flags, count in sorted(flag_counts.items()):
        print(f"  {flags}: {count}")

    print(f"\nOutput written to {args.output}")

if __name__ == "__main__":
    main()
